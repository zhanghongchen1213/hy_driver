# 实时音频流播报实现计划

为实现 ESP32-S3 驱动侧接收并播放 Python 端下发的实时音频流，我们需要解决两个核心问题：

1. **获取数据**：建立 HTTPS 长连接，实时下载音频流数据。
2. **流式播放**：将下载的数据实时喂给音频解码器，而不是等待下载完成。

由于现有的 `audio_player` 组件仅支持 `FILE*` 文件接口，我们将采用 **VFS (虚拟文件系统)** 技术来适配，创建一个“管道”文件，让播放器像读取本地文件一样读取网络流，播放是连续的而不是中断的，即一个音频在播放时，当有新的音频文件时会等待上一个音频播报完成才会继续播报。

## 1. 核心组件设计

### 1.1 虚拟文件系统 (VFS) 管道

在 `app_audio.c` 中实现一个简易的 VFS 驱动，挂载到 `/dev/net` 路径。

* **机制**：内部维护一个环形缓冲区 (RingBuffer)。

* **`open`**：返回一个虚拟文件句柄。

* **`read`**：从 RingBuffer 读取数据。**关键点**：如果 Buffer 为空，任务将**阻塞等待**，直到有新数据写入或网络断开。这实现了“实时等待播放”的效果。

* **`close`**：清理资源。

  <br />

### 1.2 wifi初始化

* 实现wifi的连接逻辑，并在main文件中正确引用。

### 1.2 HTTPS 客户端任务

创建一个 FreeRTOS 任务 `https_stream_task`，负责网络通信。

* **连接**：使用 `esp_http_client` 连接 Python 服务器 (例如 `http://192.168.22.219:8090/audio`)。

* **下载**：循环调用 `esp_http_client_read` 读取数据块。

* **写入**：将读取的数据写入 VFS 的 RingBuffer，唤醒正在等待的播放器。

### 1.3 播放控制逻辑

* 在系统启动或接收到指令后，调用 `fopen("/dev/net/stream", "r")` 打开管道。

* 调用 `audio_player_play(fp)` 启动播放。

* 播放器会自动通过 VFS 接口不断拉取数据并解码播放，直到网络流结束。

## 2. 修改文件清单

### `main/app_audio_control/app_audio.c`

* **新增**：

  * VFS 驱动实现 (`esp_vfs_t` 结构体及回调)。

  * RingBuffer 管理逻辑。

  * HTTPS Client 任务函数。

* **修改**：

  * `rtos_audio_control_init`：增加 VFS 注册和网络任务创建。

  * 添加服务器 IP 配置宏 (需用户根据实际环境修改)。

## 3. 依赖确认

* **Wi-Fi 连接**：本项目代码中暂未发现 Wi-Fi 连接逻辑。**请确保在** **`main.c`** **或其他位置已实现 Wi-Fi 连接**，否则 HTTP 任务将无法工作。

* **URL 配置**：需要您提供 Python 服务器的 IP 地址，或者在代码中预留宏定义供后续修改。

## 4. 执行步骤

1. 实现wifi连接逻辑

1) 在 `app_audio.c` 中引入 HTTP Client 和 VFS 相关头文件。
2) 实现 RingBuffer 和 VFS 接口。
3) 实现 HTTPS 客户端任务，对接 Python 服务器。
4) 在初始化函数中启动任务并触发播放。


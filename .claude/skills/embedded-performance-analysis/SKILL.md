---
name: "embedded-performance-analysis"
description: "专注于嵌入式系统性能优化。扫描代码中的循环冗余、内存泄漏、CPU 占用过高问题，提供优化建议并自动应用修复代码。"
---

# 嵌入式性能瓶颈分析专家 (Embedded Performance Analyzer)

本技能专注于识别和解决嵌入式代码中的性能瓶颈。它通过静态分析代码逻辑，结合嵌入式系统特性（如有限的 RAM/Flash、实时性要求），定位低效循环、内存泄漏风险和高 CPU 占用模式，并提供自动化的修复方案。

## 核心能力

1.  **低效代码识别**: 发现嵌套过深的循环、不必要的浮点运算、高频 ISR 中的耗时操作。
2.  **内存风险分析**: 检查动态内存分配 (`malloc/free`) 的配对情况、栈溢出风险、大数组在栈上的分配。
3.  **并发与锁**: 识别可能导致死锁的互斥锁使用、过长的临界区保护。
4.  **自动修复**: 针对识别出的问题，生成优化的代码片段并直接替换源码。

## 执行流程 (Execution Flow)

当用户请求“分析性能”、“优化代码”或“检查内存泄漏”时，按以下步骤执行：

### 1. 代码扫描 (Code Scanning)
读取目标源码文件，重点关注以下模式：
- **循环**: `for`/`while` 循环中的复杂计算、I/O 操作或延时函数。
- **内存**: `malloc`, `calloc`, `pvPortMalloc` 的调用及对应的释放。
- **中断**: `ISR` 函数体内是否存在大量逻辑或阻塞调用。
- **变量**: 全局变量的非原子访问、大结构体的按值传递。

### 2. 瓶颈分析 (Bottleneck Analysis)
对扫描结果进行评估：
- **循环冗余**: 是否有循环无关的计算可以提取到循环外？
- **内存泄漏**: 是否存在某些执行路径下未释放内存？
- **CPU 占用**: 是否存在忙等待 (`while(flag);`) 而非阻塞等待 (`osDelay`, `xSemaphoreTake`)？

### 3. 生成优化方案 (Optimization Proposal)
为每个问题制定优化策略：
- **循环优化**: 循环展开、提取公共子表达式、查表法、使用 DMA 替代循环数据搬运。
- **内存优化**: 使用静态分配替代动态分配、使用对象池、缩减栈变量大小。
- **并发优化**: 缩短临界区、使用原子操作替代锁、事件驱动替代轮询。
- **体积优化**: 移除死代码、裁剪未使用模块、调整编译器优化等级 (`-Os`/`-O2`)。

### 4. 自动修复 (Auto-Fix)
直接修改源代码应用优化：
1.  **定位**: 找到问题代码块的起始和结束行。
2.  **替换**: 用优化后的代码替换原有代码。
3.  **注释**: 添加 `// Optimization: ...` 注释说明修改内容。

### 5. 生成报告 (Generate Report)
输出包含分析结果和修复详情的 Markdown 报告。

## 输出格式 (Output Format)

```markdown
# 嵌入式性能优化报告

## 🚀 已优化的性能瓶颈 (Optimized Bottlenecks)

### 1. [优化项标题，如：移除 ISR 中的延时操作]
- **文件位置**: `src/sensor_driver.c:L120`
- **问题描述**: 在 `EXTI0_IRQHandler` 中使用了 `HAL_Delay(10)`，导致高优先级中断阻塞系统。
- **优化方案**: 改为设置标志位，在主循环或任务中处理延时逻辑。
- **修复状态**: ✅ 已自动修复

### 2. [优化项标题，如：循环内常量计算外提]
- **文件位置**: `src/dsp_algo.c:L50`
- **问题描述**: `for` 循环内包含重复的 `sin(angle)` 计算，浪费 CPU 周期。
- **优化方案**: 将 `sin(angle)` 计算提取到循环外部。
- **修复状态**: ✅ 已自动修复

## ⚠️ 潜在风险 (Potential Risks)
*（无法自动修复，需人工确认的问题）*

- **栈溢出风险**: `src/main.c:L80` 函数内定义了 4KB 的局部数组，可能超出任务堆栈限制。建议改为静态全局变量或动态分配。
```

## 使用示例

**用户输入**: "帮我优化一下 `data_process.c`，感觉处理太慢了。"

**Agent 动作**:
1. 读取 `data_process.c`。
2. 发现 `ProcessData` 函数在一个 `for` 循环中反复调用 `GetSystemConfig()`（该函数涉及 Flash 读取）。
3. 分析认为配置在循环期间不会改变。
4. **自动修复**: 将 `GetSystemConfig()` 提取到循环外，用局部变量缓存结果。
5. 生成报告：指出已消除循环内的冗余 I/O 操作。
